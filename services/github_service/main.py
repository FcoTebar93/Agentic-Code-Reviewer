"""
GitHub Service -- materializes generated code into a repository.

Phase 3 HITL change: now consumes pr.human_approved events instead of
security.approved. The gateway_service holds security.approved events
until a human reviews and approves them via the frontend. Only after
explicit human approval does pr.human_approved reach this service.

Pipeline role:
  security_service -> [security.approved] -> gateway_service (HITL)
  human approves -> [pr.human_approved] -> github_service -> [pr.created]
"""

from __future__ import annotations

import asyncio
import logging
from contextlib import asynccontextmanager

from fastapi import FastAPI
from pydantic import BaseModel

from shared.logging.logger import setup_logging
from shared.observability.metrics import metrics_response, pr_creation_latency, tasks_completed
from shared.contracts.events import (
    BaseEvent,
    EventType,
    PRRequestedPayload,
    PRCreatedPayload,
    PrApprovalPayload,
    pr_created,
)
from shared.utils.rabbitmq import EventBus, IdempotencyStore
from services.github_service.config import GitHubConfig
from services.github_service.git_ops import (
    clone_repo,
    create_branch,
    write_files,
    commit_and_push,
    open_pull_request,
)

SERVICE_NAME = "github_service"
event_bus: EventBus | None = None
cfg: GitHubConfig | None = None


@asynccontextmanager
async def lifespan(application: FastAPI):
    global event_bus, cfg
    logger = setup_logging(SERVICE_NAME)

    cfg = GitHubConfig.from_env()
    event_bus = EventBus(cfg.rabbitmq_url)
    await event_bus.connect()

    asyncio.create_task(_consume_human_approved())
    logger.info("GitHub Service ready (listening for pr.human_approved)")
    yield

    logger.info("Shutting down")
    if event_bus:
        await event_bus.close()


app = FastAPI(
    title="ADMADC - GitHub Service",
    version="0.2.0",
    description="Handles git operations, branching, and PR creation",
    lifespan=lifespan,
)
logger = logging.getLogger(SERVICE_NAME)

@app.get("/health")
async def health():
    return {"status": "ok", "service": SERVICE_NAME}


@app.get("/metrics")
async def metrics():
    return metrics_response()


@app.get("/workspace")
async def workspace_info():
    import os
    workspace = cfg.workspace_dir if cfg else "/app/workspace"
    contents = []
    if os.path.exists(workspace):
        contents = os.listdir(workspace)
    return {"workspace": workspace, "contents": contents}

async def _consume_human_approved() -> None:
    """
    Consume pr.human_approved events published by the gateway after
    a human reviewer clicks Approve in the frontend.
    """
    idem_store = IdempotencyStore()

    async def handler(event: BaseEvent) -> None:
        approval = PrApprovalPayload.model_validate(event.payload)
        if approval.decision != "approved" or not approval.pr_context:
            logger.warning(
                "Received pr.human_approved with non-approved decision for plan %s",
                approval.plan_id[:8],
            )
            return
        pr_payload = PRRequestedPayload.model_validate(approval.pr_context)
        await _handle_pr_request(pr_payload)

    await event_bus.subscribe(
        queue_name="github_service.human_approved",
        routing_keys=[EventType.PR_HUMAN_APPROVED.value],
        handler=handler,
        idempotency_store=idem_store,
        max_retries=3,
    )


async def _handle_pr_request(payload: PRRequestedPayload) -> None:
    plan_id = payload.plan_id
    logger.info("Handling PR request for plan %s", plan_id[:8])

    with pr_creation_latency.time():
        files_data = [f.model_dump() for f in payload.files]

        if payload.repo_url and cfg.github_token:
            repo_path = await clone_repo(
                payload.repo_url, cfg.workspace_dir, cfg.github_token
            )
            await create_branch(repo_path, payload.branch_name)
            written = await write_files(repo_path, files_data)
            await commit_and_push(
                repo_path, payload.branch_name,
                payload.commit_message, written,
            )
            result = await open_pull_request(
                repo_url=payload.repo_url,
                branch_name=payload.branch_name,
                title=payload.commit_message,
                body=f"Auto-generated by ADMADC for plan `{plan_id}` (security approved)",
                token=cfg.github_token,
            )

            created_payload = PRCreatedPayload(
                plan_id=plan_id,
                pr_url=result["pr_url"],
                pr_number=result["pr_number"],
                branch_name=payload.branch_name,
            )
            created_event = pr_created(SERVICE_NAME, created_payload)
            await event_bus.publish(created_event)
            logger.info("PR #%d created for plan %s", result["pr_number"], plan_id[:8])
        else:
            import os
            local_dir = os.path.join(cfg.workspace_dir, f"plan-{plan_id[:8]}")
            os.makedirs(local_dir, exist_ok=True)
            written = await write_files(local_dir, files_data)
            logger.info(
                "No repo_url or token. %d file(s) written locally to %s",
                written,
                local_dir,
            )
            # Publish pr.created with a local workspace URL so the event feed closes the loop
            created_payload = PRCreatedPayload(
                plan_id=plan_id,
                pr_url=f"file://{local_dir}",
                pr_number=0,
                branch_name=payload.branch_name,
            )
            created_event = pr_created(SERVICE_NAME, created_payload)
            await event_bus.publish(created_event)
            logger.info("pr.created published (local workspace) for plan %s", plan_id[:8])

        tasks_completed.labels(service=SERVICE_NAME).inc()
